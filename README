= External 

Indexing and array-like access to data stored on disk rather than in memory.

== Description

External provides a way to index and access entries directly from a file without
loading it into memory.  The indexes can be read into memory for performance or
stored on disk alongside the data file, in essence giving you arbitrarily large
arrays.  External provides access to the following:

ExternalIndex:: formatted binary data
ExternalArchive:: externally stored string data
ExternalArray:: externally stored ruby objects, serialized as YAML

The array-like behavior of these classes is developed using modified versions
of the RubySpec[http://rubyspec.org] specification for Array.  The idea is to 
eventually duck-type all Array methods, including sort and collect, with 
acceptable performance.

* Rubyforge[http://rubyforge.org/projects/external]
* Lighthouse[http://bahuvrihi.lighthouseapp.com/projects/10590-external]
* Github[http://github.com/bahuvrihi/external/tree/master]

=== Bugs/Known Issues

* only a limited set of array methods are currently supported
* YAML dump/load of some strings doesn't faithfully reproduce the input and
  will not be faithfully stored in ExternalArray.  Carriage returns (\r) and
  chains of newlines (\n) are notable:

  YAML.load(YAML.dump("\r"))                       # => nil
  YAML.load(YAML.dump("\r\n"))                     # => ""
  YAML.load(YAML.dump("string with \r\n inside"))  # => "string with \n inside"

  YAML.load(YAML.dump("\n"))                       # => ""
  YAML.load(YAML.dump("\n\n"))                     # => ""

--
* reindexing of ExternalArray does not work for arrays containing yaml strings
++

== Usage

=== ExternalArray

ExternalArray can be initialized from data using the [] operator and used like
an array.

  a = ExternalArray[1, 2.2, "cat", {:key => 'value'}]
  a[2]                # => "cat"
  a.last              # => {:key => 'value'}
  a << [:a, :b]
  a.to_a              # => [1, 2.2, "cat", {:key => 'value'}, [:a, :b]]

ExternalArray serializes and stores entries on a data source (io) and builds an 
io_index that tracks where each entry begins and ends.  By default ExternalArray
will serialize to a StringIO and use an Array as the io_index:

  a.io.class            # => StringIO
  a.io.string           # => "--- 1\n--- 2.2\n--- cat\n--- \n:key: value\n--- \n- :a\n- :b\n"

  a.io_index.class      # => Array
  a.io_index.to_a       # => [[0, 6], [6, 8], [14, 8], [22, 17], [39, 15]]

To save this data to disk, provide a path to <tt>close</tt>; a data file and
binary index file will be created:

  a.close('example.yml')
  File.read('example.yml')                  # => "--- 1\n--- 2.2\n--- cat\n--- \n:key: value\n--- \n- :a\n- :b\n"
  File.read('example.index').unpack('I*')   # => [0, 6, 6, 8, 14, 8, 22, 17, 39, 15]

ExternalArray can be initialized from existing data sources.  When an index file
already exists, <tt>open</tt> will use it automatically:

  ExternalArray.open('example.yml') do |b|
    b.to_a              # => [1, 2.2, "cat", {:key => 'value'}, [:a, :b]]
  end

If the index doesn't exist, tt>open</tt> will reindex the data automatically;
manual intervention may be necessary when you initialize an ExternalArray
with some arbitrary IO:

  FileUtils.rm('example.index')
  ExternalArray.open('example.yml') do |b|
    b.to_a              # => [1, 2.2, "cat", {:key => 'value'}, [:a, :b]]
  end
  
  c = ExternalArray.new File.open('example.yml')
  c.to_a                # => []
  
  c.reindex
  c.to_a                # => [1, 2.2, "cat", {:key => 'value'}, [:a, :b]]

=== ExternalArchive

ExternalArchive is like ExternalArray except that it only handles strings (in fact,
ExternalArray is a subclass of ExternalArchive which adds the YAML serialization
of the the string).  

  arc = ExternalArchive["swift", "brown", "fox"]
  arc[2]                # => "fox"
  arc.to_a              # => ["swift", "brown", "fox"]

  arc.io.class          # => StringIO
  arc.io.string         # => "swiftbrownfox"

ExternalArchives are primarily useful as a baseclass for accessing archival data.
Here is a simple parser for FASTA[http://en.wikipedia.org/wiki/Fasta_format]
data:

  # A sample FASTA entry
  # >gi|5524211|gb|AAD44166.1| cytochrome b [Elephas maximus maximus]
  # LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV
  # EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG
  # LLILILLLLLLALLSPDMLGDPDNHMPADPLNTPLHIKPEWYFLFAYAILRSVPNKLGGVLALFLSIVIL
  # GLMPFLHTSKHRSMMLRPLSQALFWTLTMDLLTLTWIGSQPVEYPYTIIGQMASILYFSIILAFLPIAGX
  # IENY
  
  class FastaEntry
    attr_reader :header, :body
    
    def initialize(str)
      @body = str.split(/\r?\n/)
      @header = body.shift
    end
  end
  
  class FastaArchive < ExternalArchive
    def str_to_entry(str); FastaEntry.new(str); end
    def entry_to_str(entry); ([entry.header] + entry.body).join("\n"); end
    
    def reindex
      reindex_by_sep('>', :entry_follows_sep => true)
    end
  end
  
  require 'open-uri'
  fasta = FastaArchive.new open('http://external.rubyforge.org/doc/tiny_fasta.txt')
  fasta.reindex
  
  fasta.length        # => 5
  fasta[1].header     # => ">gi|114329651|ref|YP_740470.1| photosystem II protein D2 [Citrus sinensis]"
  fasta[0].body       # => ["MEVNILAFIATTLFVLVPTAFLLIIYVKTVSQSD"]

The tiny_fasta.txt file is 5 FASTA entries weighing in at 4KB; the non-redundant
{NCBI protein database}[ftp://ftp.ncbi.nih.gov/blast/db/FASTA/] contains greater
than 7 million entries in a 3.56 GB file.

=== ExternalIndex

ExternalIndex provides array-like access to formatted binary data.  The index of an 
ExternalArray (when accessing a file) is an ExternalIndex configured for binary 
data like 'II'; two integers corresponding to the start position and length an entry.

  index = ExternalIndex[1, 2, 3, 4, 5, 6, {:format => 'II'}]
  index.format          # => 'I*'
  index.frame           # => 2
  index[1]              # => [3,4]
  index.to_a            # => [[1,2], [3,4], [5,6]]

ExternalIndex handles arbitrary packing formats, opening many possibilities:

  Tempfile.new('sample.txt') do |file|
    file << [1,2,3].pack("IQS")
    file << [4,5,6].pack("IQS")
    file << [7,8,9].pack("IQS")
    file.flush

    index = ExternalIndex.new(file, :format => "IQS")
    index[1]          # => [4,5,6]
    index.to_a        # => [[1,2,3], [4,5,6], [7,8,9]]
  end

== Installation

External is available from RubyForge[http://rubyforge.org/projects/external].  Use:

  % gem install external

== Info 

Copyright (c) 2006-2008, Regents of the University of Colorado.
Developer:: {Simon Chiang}[http://bahuvrihi.wordpress.com], {Biomolecular Structure Program}[http://biomol.uchsc.edu/], {Hansen Lab}[http://hsc-proteomics.uchsc.edu/hansenlab/] 
Support:: CU Denver School of Medicine Deans Academic Enrichment Fund
Licence:: {MIT-Style}[link:files/MIT-LICENSE.html]
