# == Synopsis
#
# binaryio:  a utility to make and read binary io files
#
# == Author
#
# Developer:: Simon Chiang, Biomolecular Structure Program
# Copyright:: 2006-2007, Regents of the University of Colorado.
# Support:: UCHSC School of Medicine Deans Academic Enrichment Fund
#
# == Usage
#
# binaryio <command> [options] [args]
#
# Available commands:
#   read binary_file [target]
#   write input_file [target]
#   prompt target
#   compare binary_file binary_file
#
# Options:
#   -d, --directive      specify bio directive (default=I)
#   -f, --frame          specify bio frame (default=1)
#   -h, --help           show help
#
# Arguments:
#   binary_file    The path to a binary file.    
#   input_file     The path to a txt file with numeric information.
#                  txt - parses numbers by whitespace, frames by newline
#                  ex:  "1 2\n3 4" => [[1,2],[3,4]]
#   target         The output path for reading or writing.  Defaults:
#                  read - stdout
#                  write - input_file.[d][f]bio  (d,f : directive,frame)

require 'rdoc/usage'
require 'getoptlong'
require 'pp'

usr_directive = nil
usr_frame = nil

opts = GetoptLong.new(
  [ '--directive', '-d', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--frame', '-f', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ]
)
opts.each do |opt, arg|
  case opt
  when '--directive' then usr_directive = arg
  when '--frame' then usr_frame = arg
  when '--help'
    RDoc::usage
  end
end

require 'gemdev'
require 'binaryio'

begin
  case ARGV[0].to_s.downcase
  when 'read'
    input = ARGV[1]
    target = ARGV[2] || $stdout
    
    raise "missing or non-existant binary_file: #{input}" unless input && File.exists?(input)
    
    File.extname(input) =~ /(\w)(\d+)bio$/
    directive = usr_directive || $1 || "I"
    frame = usr_frame || $2 || 1
    
    BinaryIO.open(input, "r", :directive => directive, :frame => frame.to_i) do |bio|
      begin
        target = File.open(target, "w") unless target == $stdout
        bio.each do |entry|
          target.puts entry.join(" ")
        end
      ensure
        target.close unless target == $stdout
      end
    end
    
  when 'write'
    directive = usr_directive || "I"
    frame = usr_frame || 1
    input = ARGV[1]
    target = ARGV[2] || File.join(File.basename(input).chomp(File.extname(input)) + ".#{directive}#{frame}bio")
    
    raise "missing or non-existant input_file: #{input}" unless input && File.exists?(input)
    
    File.open(input, "r") do |file|
      BinaryIO.open(target, "wm", :directive => directive, :frame => frame.to_i) do |bio|
        file.each_line do |line|
          bio.concat( line.split(/\s+/) )
        end
      end
    end
    
  when 'prompt'
    directive = usr_directive || "I"
    frame = usr_frame || 1
    target = ARGV[1]
    
    raise "missing target" unless target 
    target += ".#{directive}#{frame}bio" if File.extname(target).empty?
    
    ARGV.clear
    BinaryIO.open(target, "wm", :directive => directive, :frame => frame.to_i) do |bio|
      puts "Enter inputs:"
      while line = gets
        bio.concat( line.strip.chomp("!").split(/\s+/).collect {|s| s.to_f} )
        break if line =~ /!/
      end
    end
     
  when 'compare'
    file_a = ARGV[1]
    file_b = ARGV[2]
  
    raise "missing or non-existant binary_file: #{file_a}" unless file_a && File.exists?(file_a)
    raise "missing or non-existant binary_file: #{file_b}" unless file_b && File.exists?(file_b)

    require 'fileutils'
    if FileUtils.compare_file(file_a, file_b)
      puts "Equal"
    else
      File.extname(file_a) =~ /(\w)(\d+)bio$/
      directive_a = usr_directive || $1 || "I"
      frame_a = usr_frame || $2 || 1
  
      File.extname(file_b) =~ /(\w)(\d+)bio$/
      directive_b = usr_directive || $1 || "I"
      frame_b = usr_frame || $2 || 1

      puts "Unequal!"
      puts PP.singleline_pp(BinaryIO.read(file_a, :directive => directive_a, :frame => frame_a.to_i), "<#{file_a}>:\n")
      puts PP.singleline_pp(BinaryIO.read(file_b, :directive => directive_b, :frame => frame_b.to_i), "<#{file_b}>:\n")
    end

  else
    RDoc::usage
  end
  
rescue
	puts "\nError: #{$!.message}"
	$!.backtrace.each do |str|
	  puts str
	end
end